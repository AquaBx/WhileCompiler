function true: 
read 
% 
Result := (cons nil nil); 
% 
write Result 

function false: 
read 
% 
Result := nil; 
% 
write Result 

function not: 
read Op1 
% 
if Op1 then Result := (false) else Result := (true) fi; 
% 
write Result 

function and: 
read Op1, Op2 
% 
if (not Op1) then 
    Result := (false) 
else 
    if (not Op2) then 
        Result := (false) 
    else 
        Result := (true) 
    fi 
fi; 
% 
write Result 

function add: 
read Op1, Op2 
% 
Result := Op1; 
for Op2 do 
    Result := (cons nil Result) 
od; 
% 
write Result 

function sub: 
read Op1, Op2 
% 
Result := Op1; 
for Op2 do 
    Result := (tl Result) 
od; 
% 
write Result 

function mul: 
read Op1, Op2 
% 
Result := nil; 
for Op1 do 
    Result := (add Result Op2) 
od; 
% 
write Result 

function bigTest: 
read 
% 
    List1 := (cons a (cons b (cons c nil))); // Création d'une liste
    List2 := (cons d (cons e (cons f nil))); // Création d'une autre liste

    Bool1 := (and (true) (false));
    Bool2 := (not (true));

    ConcatenatedList := (cons List1 List2);
    Element := (hd ConcatenatedList);

    Number1 := (cons nil (cons nil (cons nil nil)));
    Number2 := (cons nil (cons nil nil));

    Sum := (add Number1 Number2);
    Difference := (sub Number1 Number2);

    Product := (mul Number1 Number2);

    foreach X in ConcatenatedList do
        print(X);
        TempSum := (add Number1 Number2);
    od;

    TestResult1 := (true);
    TestResult2 := (false);

    Result := (cons Bool1 (cons Bool2 (cons Sum (cons Difference (cons Product ConcatenatedList)))));
% 
write Result
